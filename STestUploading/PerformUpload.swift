//
//  PerformUpload.swift
//  DataTaskMinimal
//
//  Created by Fritz Anderson on 1/25/23.
//

import Foundation

let UploadNotification = Notification.Name("UploadNotification")

struct PerformUpload {
    
    typealias URLCallback = (Data?, URLResponse?, Error?) -> Void
    
    let payload: Data
    let fileName: String
    
    /// Create a manager for formatting and uploading the given payload data, into a server file with the given name
    /// - parameters:
    ///   - payload: The data to upload
    ///   - name:  The remote file name
    init(for payload: Data, named name: String) {
        self.payload  = payload
        self.fileName = name
    }
    
    /// Form a `URLRequest` from the known upload URL and a boundary string generated by the caller.
    ///
    /// Adds the root `Content-Type` to the request.
    func createRequest(boundaryString: String) -> URLRequest {
        var retval = URLRequest(
            url: UploadCreds.uploadDirURL,
            cachePolicy: .reloadIgnoringLocalCacheData)
        retval.setValue(
            "multipart/form-data; boundary=\(boundaryString)",
            forHTTPHeaderField: "Content-Type")
        retval.httpMethod = UploadCreds.method
        return retval
    }
    
    /// For the multipart data upload:
    /// * `Content-Type` header is form-data, with boundary ID = "Boundary-{UUID}", goes in the request. See ``createRequest(boundaryString:)``
    /// * Forms the payload multipart in ``multipartData(fileName:content:boundary:)``
    /// * Spawns a `Task` to perform the asynchronoous upload.
    ///
    /// Completion of the upload will trigger an `UploadNotification` notification.
    func doIt() {
        // URLRequest including the boundary string.
        let boundary = "Boundary-\(UUID().uuidString)"
        let request = createRequest(boundaryString: boundary)
        
        // Wrap the payload in a multopart envelope
        let toTransfer: Data =
        try! multipartData(fileName: fileName,
                           content : payload,
                           boundary: boundary)
        
        Task {
            do {
                // Start/complete the upload asynchronously
                let (data, response) =
                try await UpSessionDelegate.session
                    .upload(for: request,
                            from: toTransfer,
                            delegate: UploadTaskDelegate())
                
                // Send `UploadNotification` to broadcast completion
                let userInfo: [String:Any] =
                ["response": response]
                NotificationCenter.default
                    .post(name: UploadNotification,
                          object: data,
                          userInfo: userInfo)
            }
            catch {
                // This is a system-level error.
                // Might notify a .failure
                
                print("alternateUpload error:", error)
                print("I think I simply ignore it.")
            }
        }
    }
}
